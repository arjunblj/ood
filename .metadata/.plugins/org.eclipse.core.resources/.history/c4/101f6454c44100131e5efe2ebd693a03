import java.util.*;

public class RBTree {
    
    /**
     * data is the value in the RBT
     */
    String data;
    /**
     * the BST located on the left side
     */
    RBTree left;
    /**
     * the RBT located on the right side
     */
    RBTree right;
    /**
     * the comparator used to sort the RBT
     */
    Comparator<String> comp;
    /**
     * is true if the RBT is empty, false otherwise
     */
    boolean isEmpty;
    /**
     * is true if the Node is black, false otherwise
     */
    boolean isBlack;
    
    /**
     * 
     * @param data is the value in the RBT
     * @param left is the RBT on the left side
     * @param right is the RBT on the right side
     * @param comp is the comparator used to sort the RBT
     * @param isEmpty represents whether the RBT is empty
     * @param isBlack represents whether the Node is black or not
     */
    RBTree(String data, RBTree left, RBTree right, 
            Comparator<String> comp, boolean isEmpty, boolean isBlack) {
        this.data = data;
        this.left = left;
        this.right = right;
        this.comp = comp;
        this.isEmpty = isEmpty;
        this.isBlack = isBlack;
    }
        
    /**
     * 
     * @param s is the string inputed in insert
     * inserts the given string into this BST
     */
    private void insert(String s) {
        if (this.isEmpty) {
            this.data = s;
            this.left = binTree(comp);
            this.right = binTree(comp);
            this.isEmpty = false;
        }
        else {
            if ((comp.compare(this.data, s) == 0)) {
                return;
            }
            else if ((comp.compare(this.data, s)) > 0) {
                left.insert(s);
            }
            else {
                right.insert(s);
            }
        }
    }
    
    private void balance() {
        if (this.isBlack && !this.left.isBlack && !this.left.left.isBlack) {
            RBTree temp = this.left;
            this.left = this.left.left;
        }            
            else if (this.isBlack && !this.left.isBlack && 
                    !this.left.right.isBlack)
        }
    }

    /**
     * Effect: 
     * Produces a <code>String</code> that consists of 
     * all <code>String</code>s in this tree 
     * separated by comma and a space, 
     * generated in the order defined by this tree's 
     * <code>Comparator</code>.
     * So for a tree with <code>Strings</code> 
     * "hello" "bye" and "aloha" 
     * ordered lexicographically, 
     * the result would be "aloha, bye, hello"
     * 
     * @return produces a a string "x1, x2 ... xn"
     */
    public String toString() {
        if ((this.isEmpty)) {
            return "";
        }
        else {
            if ((this.left.isEmpty &&
                    this.right.isEmpty)) {
                return this.data;
            }
            else {
                if ((this.left.isEmpty &&
                        !this.right.isEmpty)) {
                    return this.right.toString() + ", " + this.data;
                }
                else {
                    if ((!this.left.isEmpty &&
                            this.right.isEmpty)) {
                        return this.left.toString() + ", " + this.data;
                    }
                    else {
                        return this.left.toString() + ", " +
                                this.data + ", " +
                                this.right.toString();
                    }
                }
            }
        }
    }

    /**
     * Factory method to generate 
     * an empty RBTree
     * with the given <code>Comparator</code>
     *
     * @param comp the given <code>Comparator</code>
     * @return new empty binary search tree that uses the 
     *         given <code>Comparator</code> for ordering
     */
    public static RBTree binTree(Comparator<String> comp) {
        return new RBTree("", null, null, comp, true, true);
    }

    /**
     * Effect: 
     * Produces an integer that is compatible 
     * with the implemented  equals method 
     * and is likely to be different 
     * for objects that are not equal.
     * 
     * @return returns the hashCode of this BST
     */
    public int hashCode() {
        return this.data.hashCode() * 2;
    }

    /**
     * Effect: 
     * Produces false if o is not an instance of BTree.
     * Produces true if this tree and the given BTree 
     * contain the same <code>String</code>s and
     * are ordered by the same <code>Comparator</code>.
     * So if the first tree was built with Strings 
     * "hello" "bye" and "aloha" ordered
     * lexicographically,  and the second tree was built 
     * with <code>String</code>s "aloha" "hello" and "bye"  
     * and ordered lexicographically, 
     * the result would be true.
     *
     * @param o the object to compare with this
     * @return returns t if this BST and the given Object is true
     */
    public boolean equals(Object o) {
        return this.hashCode() == o.hashCode();
    }
    
}
